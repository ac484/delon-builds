import { addDays, endOfDay, endOfMonth, endOfWeek, endOfYear, parse, parseISO, startOfDay, startOfMonth, startOfWeek, startOfYear, subMonths, subWeeks, subYears } from 'date-fns';
/**
 * Get the time range, return `[ Date, Date]` for the start and end dates
 *
 * 获取时间范围
 *
 * @param type 类型，带 `-` 表示过去一个时间，若指定 `number` 表示天数
 * @param time 开始时间
 * @param ignoreMaxTime 忽略追加结束日期的最大时间值
 */
export function getTimeDistance(type, time, options) {
    time = time
        ? typeof time === 'string'
            ? parse(time, 'yyyy-MM-dd HH:mm:ss', new Date())
            : new Date(time)
        : new Date();
    const opt = { weekStartsOn: 1 };
    let res;
    switch (type) {
        case 'today':
            res = [time, time];
            break;
        case '-today':
            res = [addDays(time, -1), time];
            break;
        case 'yesterday':
            res = [addDays(time, -1), addDays(time, -1)];
            break;
        case 'week':
            res = [startOfWeek(time, opt), endOfWeek(time, opt)];
            break;
        case '-week':
            res = [startOfWeek(subWeeks(time, 1), opt), endOfWeek(subWeeks(time, 1), opt)];
            break;
        case 'month':
            res = [startOfMonth(time), endOfMonth(time)];
            break;
        case '-month':
            res = [startOfMonth(subMonths(time, 1)), endOfMonth(subMonths(time, 1))];
            break;
        case 'year':
            res = [startOfYear(time), endOfYear(time)];
            break;
        case '-year':
            res = [startOfYear(subYears(time, 1)), endOfYear(subYears(time, 1))];
            break;
        default:
            res = type > 0 ? [time, addDays(time, type)] : [addDays(time, type), time];
            break;
    }
    return options?.ignoreMaxTime ? res : fixEndTimeOfRange(res);
}
/**
 * fix time is the most, big value
 */
export function fixEndTimeOfRange(dates) {
    return [startOfDay(dates[0]), endOfDay(dates[1])];
}
/**
 * Return the date parsed from string using the given format string
 * - If the argument is a number, it is treated as a timestamp.
 *
 * @param formatString If parsing fails try to parse the date by pressing `formatString`
 * @param defaultValue If parsing fails returned default value, default: `new Date(NaN)`
 */
export function toDate(value, options) {
    if (typeof options === 'string')
        options = { formatString: options };
    const { formatString, defaultValue } = {
        formatString: 'yyyy-MM-dd HH:mm:ss',
        defaultValue: new Date(NaN),
        ...options
    };
    if (value == null) {
        return defaultValue;
    }
    if (value instanceof Date) {
        return value;
    }
    if (typeof value === 'number' || (typeof value === 'string' && /[0-9]{10,13}/.test(value))) {
        return new Date(+value);
    }
    let tryDate = parseISO(value);
    if (isNaN(tryDate)) {
        tryDate = parse(value, formatString, new Date());
    }
    return isNaN(tryDate) ? defaultValue : tryDate;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3V0aWwvZGF0ZS10aW1lL3RpbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLE9BQU8sRUFDUCxRQUFRLEVBQ1IsVUFBVSxFQUNWLFNBQVMsRUFDVCxTQUFTLEVBQ1QsS0FBSyxFQUNMLFFBQVEsRUFDUixVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxXQUFXLEVBQ1gsU0FBUyxFQUNULFFBQVEsRUFDUixRQUFRLEVBQ1QsTUFBTSxVQUFVLENBQUM7QUFJbEI7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLFVBQVUsZUFBZSxDQUM3QixJQUEwRyxFQUMxRyxJQUE2QixFQUM3QixPQUFxQztJQUVyQyxJQUFJLEdBQUcsSUFBSTtRQUNULENBQUMsQ0FBQyxPQUFPLElBQUksS0FBSyxRQUFRO1lBQ3hCLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLHFCQUFxQixFQUFFLElBQUksSUFBSSxFQUFFLENBQUM7WUFDaEQsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQztRQUNsQixDQUFDLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQztJQUNmLE1BQU0sR0FBRyxHQUF3QixFQUFFLFlBQVksRUFBRSxDQUFDLEVBQUUsQ0FBQztJQUVyRCxJQUFJLEdBQWlCLENBQUM7SUFDdEIsUUFBUSxJQUFJLEVBQUU7UUFDWixLQUFLLE9BQU87WUFDVixHQUFHLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFDbkIsTUFBTTtRQUNSLEtBQUssUUFBUTtZQUNYLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNoQyxNQUFNO1FBQ1IsS0FBSyxXQUFXO1lBQ2QsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFD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LElBQUksSUFBSSxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDekI7SUFDRCxJQUFJLE9BQU8sR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDOUIsSUFBSSxLQUFLLENBQUMsT0FBb0IsQ0FBQyxFQUFFO1FBQy9CLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLFlBQWEsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7S0FDbkQ7SUFFRCxPQUFPLEtBQUssQ0FBQyxPQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBQzlELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBhZGREYXlzLFxuICBlbmRPZkRheSxcbiAgZW5kT2ZNb250aCxcbiAgZW5kT2ZXZWVrLFxuICBlbmRPZlllYXIsXG4gIHBhcnNlLFxuICBwYXJzZUlTTyxcbiAgc3RhcnRPZkRheSxcbiAgc3RhcnRPZk1vbnRoLFxuICBzdGFydE9mV2VlayxcbiAgc3RhcnRPZlllYXIsXG4gIHN1Yk1vbnRocyxcbiAgc3ViV2Vla3MsXG4gIHN1YlllYXJzXG59IGZyb20gJ2RhdGUtZm5zJztcblxuaW1wb3J0IHR5cGUgeyBOelNhZmVBbnkgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdHlwZXMnO1xuXG4vKipcbiAqIEdldCB0aGUgdGltZSByYW5nZSwgcmV0dXJuIGBbIERhdGUsIERhdGVdYCBmb3IgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAqXG4gKiDojrflj5bml7bpl7TojIPlm7RcbiAqXG4gKiBAcGFyYW0gdHlwZSDnsbvlnovvvIzluKYgYC1gIOihqOekuui/h+WOu+S4gOS4quaXtumXtO+8jOiLpeaMh+WumiBgbnVtYmVyYCDooajnpLrlpKnmlbBcbiAqIEBwYXJhbSB0aW1lIOW8gOWni+aXtumXtFxuICogQHBhcmFtIGlnbm9yZU1heFRpbWUg5b+955Wl6L+95Yqg57uT5p2f5pel5pyf55qE5pyA5aSn5pe26Ze05YC8XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRUaW1lRGlzdGFuY2UoXG4gIHR5cGU6ICd0b2RheScgfCAnLXRvZGF5JyB8ICd5ZXN0ZXJkYXknIHwgJ3dlZWsnIHwgJy13ZWVrJyB8ICdtb250aCcgfCAnLW1vbnRoJyB8ICd5ZWFyJyB8ICcteWVhcicgfCBudW1iZXIsXG4gIHRpbWU/OiBEYXRlIHwgc3RyaW5nIHwgbnVtYmVyLFxuICBvcHRpb25zPzogeyBpZ25vcmVNYXhUaW1lPzogYm9vbGVhbiB9XG4pOiBbRGF0ZSwgRGF0ZV0ge1xuICB0aW1lID0gdGltZVxuICAgID8gdHlwZW9mIHRpbWUgPT09ICdzdHJpbmcnXG4gICAgICA/IHBhcnNlKHRpbWUsICd5eXl5LU1NLWRkIEhIOm1tOnNzJywgbmV3IERhdGUoKSlcbiAgICAgIDogbmV3IERhdGUodGltZSlcbiAgICA6IG5ldyBEYXRlKCk7XG4gIGNvbnN0IG9wdDogeyB3ZWVrU3RhcnRzT246IDEgfSA9IHsgd2Vla1N0YXJ0c09uOiAxIH07XG5cbiAgbGV0IHJlczogW0RhdGUsIERhdGVdO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd0b2RheSc6XG4gICAgICByZXMgPSBbdGltZSwgdGltZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICctdG9kYXknOlxuICAgICAgcmVzID0gW2FkZERheXModGltZSwgLTEpLCB0aW1lXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3llc3RlcmRheSc6XG4gICAgICByZXMgPSBbYWRkRGF5cyh0aW1lLCAtMSksIGFkZERheXModGltZSwgLTEpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgcmVzID0gW3N0YXJ0T2ZXZWVrKHRpbWUsIG9wdCksIGVuZE9mV2Vlayh0aW1lLCBvcHQpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy13ZWVrJzpcbiAgICAgIHJlcyA9IFtzdGFydE9mV2VlayhzdWJXZWVrcyh0aW1lLCAxKSwgb3B0KSwgZW5kT2ZXZWVrKHN1YldlZWtzKHRpbWUsIDEpLCBvcHQpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJlcyA9IFtzdGFydE9mTW9udGgodGltZSksIGVuZE9mTW9udGgodGltZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLW1vbnRoJzpcbiAgICAgIHJlcyA9IFtzdGFydE9mTW9udGgoc3ViTW9udGhzKHRpbWUsIDEpKSwgZW5kT2ZNb250aChzdWJNb250aHModGltZSwgMSkpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgcmVzID0gW3N0YXJ0T2ZZZWFyKHRpbWUpLCBlbmRPZlllYXIodGltZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLXllYXInOlxuICAgICAgcmVzID0gW3N0YXJ0T2ZZZWFyKHN1YlllYXJzKHRpbWUsIDEpKSwgZW5kT2ZZZWFyKHN1YlllYXJzKHRpbWUsIDEpKV07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVzID0gdHlwZSA+IDAgPyBbdGltZSwgYWRkRGF5cyh0aW1lLCB0eXBlKV0gOiBbYWRkRGF5cyh0aW1lLCB0eXBlKSwgdGltZV07XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gb3B0aW9ucz8uaWdub3JlTWF4VGltZSA/IHJlcyA6IGZpeEVuZFRpbWVPZlJhbmdlKHJlcyk7XG59XG5cbi8qKlxuICogZml4IHRpbWUgaXMgdGhlIG1vc3QsIGJpZyB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZml4RW5kVGltZU9mUmFuZ2UoZGF0ZXM6IFtEYXRlLCBEYXRlXSk6IFtEYXRlLCBEYXRlXSB7XG4gIHJldHVybiBbc3RhcnRPZkRheShkYXRlc1swXSksIGVuZE9mRGF5KGRhdGVzWzFdKV07XG59XG5cbmV4cG9ydCB0eXBlIFRvRGF0ZU9wdGlvbnMgPSBzdHJpbmcgfCB7IGZvcm1hdFN0cmluZz86IHN0cmluZzsgZGVmYXVsdFZhbHVlPzogTnpTYWZlQW55IH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBkYXRlIHBhcnNlZCBmcm9tIHN0cmluZyB1c2luZyB0aGUgZ2l2ZW4gZm9ybWF0IHN0cmluZ1xuICogLSBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXG4gKlxuICogQHBhcmFtIGZvcm1hdFN0cmluZyBJZiBwYXJzaW5nIGZhaWxzIHRyeSB0byBwYXJzZSB0aGUgZGF0ZSBieSBwcmVzc2luZyBgZm9ybWF0U3RyaW5nYFxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSBJZiBwYXJzaW5nIGZhaWxzIHJldHVybmVkIGRlZmF1bHQgdmFsdWUsIGRlZmF1bHQ6IGBuZXcgRGF0ZShOYU4pYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EYXRlKHZhbHVlPzogRGF0ZSB8IHN0cmluZyB8IG51bWJlciB8IG51bGwsIG9wdGlvbnM/OiBUb0RhdGVPcHRpb25zKTogRGF0ZSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMgPSB7IGZvcm1hdFN0cmluZzogb3B0aW9ucyB9O1xuICBjb25zdCB7IGZvcm1hdFN0cmluZywgZGVmYXVsdFZhbHVlIH0gPSB7XG4gICAgZm9ybWF0U3RyaW5nOiAneXl5eS1NTS1kZCBISDptbTpzcycsXG4gICAgZGVmYXVsdFZhbHVlOiBuZXcgRGF0ZShOYU4pLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgL1swLTldezEwLDEzfS8udGVzdCh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCt2YWx1ZSk7XG4gIH1cbiAgbGV0IHRyeURhdGUgPSBwYXJzZUlTTyh2YWx1ZSk7XG4gIGlmIChpc05hTih0cnlEYXRlIGFzIE56U2FmZUFueSkpIHtcbiAgICB0cnlEYXRlID0gcGFyc2UodmFsdWUsIGZvcm1hdFN0cmluZyEsIG5ldyBEYXRlKCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzTmFOKHRyeURhdGUgYXMgTnpTYWZlQW55KSA/IGRlZmF1bHRWYWx1ZSA6IHRyeURhdGU7XG59XG4iXX0=