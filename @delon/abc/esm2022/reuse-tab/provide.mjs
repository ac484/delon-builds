import { makeEnvironmentProviders } from '@angular/core';
import { RouteReuseStrategy } from '@angular/router';
import { REUSE_TAB_CACHED_MANAGER, ReuseTabCachedManagerFactory } from './reuse-tab.cache';
import { ReuseTabService } from './reuse-tab.service';
import { REUSE_TAB_STORAGE_KEY, REUSE_TAB_STORAGE_STATE, ReuseTabLocalStorageState } from './reuse-tab.state';
import { ReuseTabStrategy } from './reuse-tab.strategy';
export var ReuseTabFeatureKind;
(function (ReuseTabFeatureKind) {
    ReuseTabFeatureKind[ReuseTabFeatureKind["CacheManager"] = 0] = "CacheManager";
    ReuseTabFeatureKind[ReuseTabFeatureKind["Store"] = 1] = "Store";
})(ReuseTabFeatureKind || (ReuseTabFeatureKind = {}));
function makeFeature(kind, providers) {
    return {
        ɵkind: kind,
        ɵproviders: providers
    };
}
/**
 * Configures reuse-tab to be available for injection.
 *
 * @see {@link withLocalStorage}
 * @see {@link withCacheManager}
 */
export function provideReuseTabConfig(options) {
    const providers = [
        {
            provide: REUSE_TAB_STORAGE_KEY,
            useValue: options?.storeKey ?? '_reuse-tab-state'
        },
        (options?.cacheManager ?? withCacheManager()).ɵproviders,
        (options?.store ?? withLocalStorage()).ɵproviders,
        {
            provide: RouteReuseStrategy,
            useClass: ReuseTabStrategy,
            deps: [ReuseTabService]
        }
    ];
    return makeEnvironmentProviders(providers);
}
export function withCacheManager() {
    return makeFeature(ReuseTabFeatureKind.CacheManager, [
        {
            provide: REUSE_TAB_CACHED_MANAGER,
            useFactory: () => new ReuseTabCachedManagerFactory()
        }
    ]);
}
export function withLocalStorage() {
    return makeFeature(ReuseTabFeatureKind.Store, [
        {
            provide: REUSE_TAB_STORAGE_STATE,
            useFactory: () => new ReuseTabLocalStorageState()
        }
    ]);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdmlkZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL2FiYy9yZXVzZS10YWIvcHJvdmlkZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQWtDLHdCQUF3QixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pGLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXJELE9BQU8sRUFBRSx3QkFBd0IsRUFBRSw0QkFBNEIsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQzNGLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUN0RCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsdUJBQXVCLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUM5RyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV4RCxNQUFNLENBQU4sSUFBWSxtQkFHWDtBQUhELFdBQVksbUJBQW1CO0lBQzdCLDZFQUFZLENBQUE7SUFDWiwrREFBSyxDQUFBO0FBQ1AsQ0FBQyxFQUhXLG1CQUFtQixLQUFuQixtQkFBbUIsUUFHOUI7QUFPRCxTQUFTLFdBQVcsQ0FBb0MsSUFBVyxFQUFFLFNBQXFCO0lBQ3hGLE9BQU87UUFDTCxLQUFLLEVBQUUsSUFBSTtRQUNYLFVBQVUsRUFBRSxTQUFTO0tBQ3RCLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUscUJBQXFCLENBQUMsT0FJckM7SUFDQyxNQUFNLFNBQVMsR0FBZTtRQUM1QjtZQUNFLE9BQU8sRUFBRSxxQkFBcUI7WUFDOUIsUUFBUSxFQUFFLE9BQU8sRUFBRSxRQUFRLElBQUksa0JBQWtCO1NBQ2xEO1FBQ0QsQ0FBQyxPQUFPLEVBQUUsWUFBWSxJQUFJLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxVQUFVO1FBQ3hELENBQUMsT0FBTyxFQUFFLEtBQUssSUFBSSxnQkFBZ0IsRUFBRSxDQUFDLENBQUMsVUFBVTtRQUNqRDtZQUNFLE9BQU8sRUFBRSxrQkFBa0I7WUFDM0IsUUFBUSxFQUFFLGdCQUFnQjtZQUMxQixJQUFJLEVBQUUsQ0FBQyxlQUFlLENBQUM7U0FDeEI7S0FDRixDQUFDO0lBRUYsT0FBTyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztBQUM3QyxDQUFDO0FBRUQsTUFBTSxVQUFVLGdCQUFnQjtJQUM5QixPQUFPLFdBQVcsQ0FBQyxtQkFBbUIsQ0FBQyxZQUFZLEVBQUU7UUFDbkQ7WUFDRSxPQUFPLEVBQUUsd0JBQXdCO1lBQ2pDLFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxJQUFJLDRCQUE0QixFQUFFO1NBQ3JEO0tBQ0YsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELE1BQU0sVUFBVSxnQkFBZ0I7SUFDOUIsT0FBTyxXQUFXLENBQUMsbUJBQW1CLENBQUMsS0FBSyxFQUFFO1FBQzVDO1lBQ0UsT0FBTyxFQUFFLHVCQUF1QjtZQUNoQyxVQUFVLEVBQUUsR0FBRyxFQUFFLENBQUMsSUFBSSx5QkFBeUIsRUFBRTtTQUNsRDtLQUNGLENBQUMsQ0FBQztBQUNMLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbnZpcm9ubWVudFByb3ZpZGVycywgUHJvdmlkZXIsIG1ha2VFbnZpcm9ubWVudFByb3ZpZGVycyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVSZXVzZVN0cmF0ZWd5IH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcblxuaW1wb3J0IHsgUkVVU0VfVEFCX0NBQ0hFRF9NQU5BR0VSLCBSZXVzZVRhYkNhY2hlZE1hbmFnZXJGYWN0b3J5IH0gZnJvbSAnLi9yZXVzZS10YWIuY2FjaGUnO1xuaW1wb3J0IHsgUmV1c2VUYWJTZXJ2aWNlIH0gZnJvbSAnLi9yZXVzZS10YWIuc2VydmljZSc7XG5pbXBvcnQgeyBSRVVTRV9UQUJfU1RPUkFHRV9LRVksIFJFVVNFX1RBQl9TVE9SQUdFX1NUQVRFLCBSZXVzZVRhYkxvY2FsU3RvcmFnZVN0YXRlIH0gZnJvbSAnLi9yZXVzZS10YWIuc3RhdGUnO1xuaW1wb3J0IHsgUmV1c2VUYWJTdHJhdGVneSB9IGZyb20gJy4vcmV1c2UtdGFiLnN0cmF0ZWd5JztcblxuZXhwb3J0IGVudW0gUmV1c2VUYWJGZWF0dXJlS2luZCB7XG4gIENhY2hlTWFuYWdlcixcbiAgU3RvcmVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSZXVzZVRhYkZlYXR1cmU8S2luZFQgZXh0ZW5kcyBSZXVzZVRhYkZlYXR1cmVLaW5kPiB7XG4gIMm1a2luZDogS2luZFQ7XG4gIMm1cHJvdmlkZXJzOiBQcm92aWRlcltdO1xufVxuXG5mdW5jdGlvbiBtYWtlRmVhdHVyZTxLaW5kVCBleHRlbmRzIFJldXNlVGFiRmVhdHVyZUtpbmQ+KGtpbmQ6IEtpbmRULCBwcm92aWRlcnM6IFByb3ZpZGVyW10pOiBSZXVzZVRhYkZlYXR1cmU8S2luZFQ+IHtcbiAgcmV0dXJuIHtcbiAgICDJtWtpbmQ6IGtpbmQsXG4gICAgybVwcm92aWRlcnM6IHByb3ZpZGVyc1xuICB9O1xufVxuXG4vKipcbiAqIENvbmZpZ3VyZXMgcmV1c2UtdGFiIHRvIGJlIGF2YWlsYWJsZSBmb3IgaW5qZWN0aW9uLlxuICpcbiAqIEBzZWUge0BsaW5rIHdpdGhMb2NhbFN0b3JhZ2V9XG4gKiBAc2VlIHtAbGluayB3aXRoQ2FjaGVNYW5hZ2VyfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvdmlkZVJldXNlVGFiQ29uZmlnKG9wdGlvbnM/OiB7XG4gIHN0b3JlS2V5Pzogc3RyaW5nO1xuICBjYWNoZU1hbmFnZXI/OiBSZXVzZVRhYkZlYXR1cmU8UmV1c2VUYWJGZWF0dXJlS2luZC5DYWNoZU1hbmFnZXI+O1xuICBzdG9yZT86IFJldXNlVGFiRmVhdHVyZTxSZXVzZVRhYkZlYXR1cmVLaW5kLlN0b3JlPjtcbn0pOiBFbnZpcm9ubWVudFByb3ZpZGVycyB7XG4gIGNvbnN0IHByb3ZpZGVyczogUHJvdmlkZXJbXSA9IFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBSRVVTRV9UQUJfU1RPUkFHRV9LRVksXG4gICAgICB1c2VWYWx1ZTogb3B0aW9ucz8uc3RvcmVLZXkgPz8gJ19yZXVzZS10YWItc3RhdGUnXG4gICAgfSxcbiAgICAob3B0aW9ucz8uY2FjaGVNYW5hZ2VyID8/IHdpdGhDYWNoZU1hbmFnZXIoKSkuybVwcm92aWRlcnMsXG4gICAgKG9wdGlvbnM/LnN0b3JlID8/IHdpdGhMb2NhbFN0b3JhZ2UoKSkuybVwcm92aWRlcnMsXG4gICAge1xuICAgICAgcHJvdmlkZTogUm91dGVSZXVzZVN0cmF0ZWd5LFxuICAgICAgdXNlQ2xhc3M6IFJldXNlVGFiU3RyYXRlZ3ksXG4gICAgICBkZXBzOiBbUmV1c2VUYWJTZXJ2aWNlXVxuICAgIH1cbiAgXTtcblxuICByZXR1cm4gbWFrZUVudmlyb25tZW50UHJvdmlkZXJzKHByb3ZpZGVycyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoQ2FjaGVNYW5hZ2VyKCk6IFJldXNlVGFiRmVhdHVyZTxSZXVzZVRhYkZlYXR1cmVLaW5kLkNhY2hlTWFuYWdlcj4ge1xuICByZXR1cm4gbWFrZUZlYXR1cmUoUmV1c2VUYWJGZWF0dXJlS2luZC5DYWNoZU1hbmFnZXIsIFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBSRVVTRV9UQUJfQ0FDSEVEX01BTkFHRVIsXG4gICAgICB1c2VGYWN0b3J5OiAoKSA9PiBuZXcgUmV1c2VUYWJDYWNoZWRNYW5hZ2VyRmFjdG9yeSgpXG4gICAgfVxuICBdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdpdGhMb2NhbFN0b3JhZ2UoKTogUmV1c2VUYWJGZWF0dXJlPFJldXNlVGFiRmVhdHVyZUtpbmQuU3RvcmU+IHtcbiAgcmV0dXJuIG1ha2VGZWF0dXJlKFJldXNlVGFiRmVhdHVyZUtpbmQuU3RvcmUsIFtcbiAgICB7XG4gICAgICBwcm92aWRlOiBSRVVTRV9UQUJfU1RPUkFHRV9TVEFURSxcbiAgICAgIHVzZUZhY3Rvcnk6ICgpID0+IG5ldyBSZXVzZVRhYkxvY2FsU3RvcmFnZVN0YXRlKClcbiAgICB9XG4gIF0pO1xufVxuIl19